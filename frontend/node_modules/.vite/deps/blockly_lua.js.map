{
  "version": 3,
  "sources": ["../../../../ltm-react/node_modules/blockly/generators/lua/lists.ts", "../../../../ltm-react/node_modules/blockly/generators/lua/logic.ts", "../../../../ltm-react/node_modules/blockly/generators/lua/loops.ts", "../../../../ltm-react/node_modules/blockly/generators/lua/math.ts", "../../../../ltm-react/node_modules/blockly/generators/lua/procedures.ts", "../../../../ltm-react/node_modules/blockly/generators/lua/text.ts", "../../../../ltm-react/node_modules/blockly/generators/lua/variables.ts", "../../../../ltm-react/node_modules/blockly/generators/lua/lua_generator.ts", "../../../../ltm-react/node_modules/blockly/generators/lua/variables_dynamic.ts", "../../../../ltm-react/node_modules/blockly/generators/lua.ts", "../../../../ltm-react/node_modules/blockly/lua.mjs"],
  "sourcesContent": ["/**\n * @license\n * Copyright 2016 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\n/**\n * @file Generating Lua for list blocks.\n */\n\n// Former goog.module ID: Blockly.Lua.lists\n\nimport type {CreateWithBlock} from '../../blocks/lists.js';\nimport type {Block} from '../../core/block.js';\nimport {NameType} from '../../core/names.js';\nimport type {LuaGenerator} from './lua_generator.js';\nimport {Order} from './lua_generator.js';\n\nexport function lists_create_empty(\n  block: Block,\n  generator: LuaGenerator,\n): [string, Order] {\n  // Create an empty list.\n  return ['{}', Order.HIGH];\n}\n\nexport function lists_create_with(\n  block: Block,\n  generator: LuaGenerator,\n): [string, Order] {\n  const createWithBlock = block as CreateWithBlock;\n  // Create a list with any number of elements of any type.\n  const elements = new Array(createWithBlock.itemCount_);\n  for (let i = 0; i < createWithBlock.itemCount_; i++) {\n    elements[i] =\n      generator.valueToCode(createWithBlock, 'ADD' + i, Order.NONE) || 'nil';\n  }\n  const code = '{' + elements.join(', ') + '}';\n  return [code, Order.HIGH];\n}\n\nexport function lists_repeat(\n  block: Block,\n  generator: LuaGenerator,\n): [string, Order] {\n  // Create a list with one element repeated.\n  const functionName = generator.provideFunction_(\n    'create_list_repeated',\n    `\nfunction ${generator.FUNCTION_NAME_PLACEHOLDER_}(item, count)\n  local t = {}\n  for i = 1, count do\n    table.insert(t, item)\n  end\n  return t\nend\n  `,\n  );\n  const element = generator.valueToCode(block, 'ITEM', Order.NONE) || 'nil';\n  const repeatCount = generator.valueToCode(block, 'NUM', Order.NONE) || '0';\n  const code = functionName + '(' + element + ', ' + repeatCount + ')';\n  return [code, Order.HIGH];\n}\n\nexport function lists_length(\n  block: Block,\n  generator: LuaGenerator,\n): [string, Order] {\n  // String or array length.\n  const list = generator.valueToCode(block, 'VALUE', Order.UNARY) || '{}';\n  return ['#' + list, Order.UNARY];\n}\n\nexport function lists_isEmpty(\n  block: Block,\n  generator: LuaGenerator,\n): [string, Order] {\n  // Is the string null or array empty?\n  const list = generator.valueToCode(block, 'VALUE', Order.UNARY) || '{}';\n  const code = '#' + list + ' == 0';\n  return [code, Order.RELATIONAL];\n}\n\nexport function lists_indexOf(\n  block: Block,\n  generator: LuaGenerator,\n): [string, Order] {\n  // Find an item in the list.\n  const item = generator.valueToCode(block, 'FIND', Order.NONE) || \"''\";\n  const list = generator.valueToCode(block, 'VALUE', Order.NONE) || '{}';\n  let functionName;\n  if (block.getFieldValue('END') === 'FIRST') {\n    functionName = generator.provideFunction_(\n      'first_index',\n      `\nfunction ${generator.FUNCTION_NAME_PLACEHOLDER_}(t, elem)\n  for k, v in ipairs(t) do\n    if v == elem then\n      return k\n    end\n  end\n  return 0\nend\n`,\n    );\n  } else {\n    functionName = generator.provideFunction_(\n      'last_index',\n      `\nfunction ${generator.FUNCTION_NAME_PLACEHOLDER_}(t, elem)\n  for i = #t, 1, -1 do\n    if t[i] == elem then\n      return i\n    end\n  end\n  return 0\nend\n`,\n    );\n  }\n  const code = functionName + '(' + list + ', ' + item + ')';\n  return [code, Order.HIGH];\n}\n\n/**\n * Returns an expression calculating the index into a list.\n *\n * @param listName Name of the list, used to calculate length.\n * @param where The method of indexing, selected by dropdown in Blockly\n * @param opt_at The optional offset when indexing from start/end.\n * @returns Index expression.\n */\nconst getListIndex = function (\n  listName: string,\n  where: string,\n  opt_at: string,\n): string {\n  if (where === 'FIRST') {\n    return '1';\n  } else if (where === 'FROM_END') {\n    return '#' + listName + ' + 1 - ' + opt_at;\n  } else if (where === 'LAST') {\n    return '#' + listName;\n  } else if (where === 'RANDOM') {\n    return 'math.random(#' + listName + ')';\n  } else {\n    return opt_at;\n  }\n};\n\nexport function lists_getIndex(\n  block: Block,\n  generator: LuaGenerator,\n): [string, Order] | string {\n  // Get element at index.\n  // Note: Until January 2013 this block did not have MODE or WHERE inputs.\n  const mode = block.getFieldValue('MODE') || 'GET';\n  const where = block.getFieldValue('WHERE') || 'FROM_START';\n  const list = generator.valueToCode(block, 'VALUE', Order.HIGH) || '({})';\n\n  // If `list` would be evaluated more than once (which is the case for LAST,\n  // FROM_END, and RANDOM) and is non-trivial, make sure to access it only once.\n  if (\n    (where === 'LAST' || where === 'FROM_END' || where === 'RANDOM') &&\n    !list.match(/^\\w+$/)\n  ) {\n    // `list` is an expression, so we may not evaluate it more than once.\n    if (mode === 'REMOVE') {\n      // We can use multiple statements.\n      const atOrder = where === 'FROM_END' ? Order.ADDITIVE : Order.NONE;\n      let at = generator.valueToCode(block, 'AT', atOrder) || '1';\n      const listVar = generator.nameDB_!.getDistinctName(\n        'tmp_list',\n        NameType.VARIABLE,\n      );\n      at = getListIndex(listVar, where, at);\n      const code =\n        listVar +\n        ' = ' +\n        list +\n        '\\n' +\n        'table.remove(' +\n        listVar +\n        ', ' +\n        at +\n        ')\\n';\n      return code;\n    } else {\n      // We need to create a procedure to avoid reevaluating values.\n      const at = generator.valueToCode(block, 'AT', Order.NONE) || '1';\n      let functionName;\n      if (mode === 'GET') {\n        functionName = generator.provideFunction_(\n          'list_get_' + where.toLowerCase(),\n          [\n            'function ' +\n              generator.FUNCTION_NAME_PLACEHOLDER_ +\n              '(t' +\n              // The value for 'FROM_END' and'FROM_START' depends on `at` so\n              // we add it as a parameter.\n              (where === 'FROM_END' || where === 'FROM_START' ? ', at)' : ')'),\n            '  return t[' + getListIndex('t', where, 'at') + ']',\n            'end',\n          ],\n        );\n      } else {\n        // `mode` === 'GET_REMOVE'\n        functionName = generator.provideFunction_(\n          'list_remove_' + where.toLowerCase(),\n          [\n            'function ' +\n              generator.FUNCTION_NAME_PLACEHOLDER_ +\n              '(t' +\n              // The value for 'FROM_END' and'FROM_START' depends on `at` so\n              // we add it as a parameter.\n              (where === 'FROM_END' || where === 'FROM_START' ? ', at)' : ')'),\n            '  return table.remove(t, ' + getListIndex('t', where, 'at') + ')',\n            'end',\n          ],\n        );\n      }\n      const code =\n        functionName +\n        '(' +\n        list +\n        // The value for 'FROM_END' and 'FROM_START' depends on `at` so we\n        // pass it.\n        (where === 'FROM_END' || where === 'FROM_START' ? ', ' + at : '') +\n        ')';\n      return [code, Order.HIGH];\n    }\n  } else {\n    // Either `list` is a simple variable, or we only need to refer to `list`\n    // once.\n    const atOrder =\n      mode === 'GET' && where === 'FROM_END' ? Order.ADDITIVE : Order.NONE;\n    let at = generator.valueToCode(block, 'AT', atOrder) || '1';\n    at = getListIndex(list, where, at);\n    if (mode === 'GET') {\n      const code = list + '[' + at + ']';\n      return [code, Order.HIGH];\n    } else {\n      const code = 'table.remove(' + list + ', ' + at + ')';\n      if (mode === 'GET_REMOVE') {\n        return [code, Order.HIGH];\n      } else {\n        // `mode` === 'REMOVE'\n        return code + '\\n';\n      }\n    }\n  }\n}\n\nexport function lists_setIndex(block: Block, generator: LuaGenerator): string {\n  // Set element at index.\n  // Note: Until February 2013 this block did not have MODE or WHERE inputs.\n  let list = generator.valueToCode(block, 'LIST', Order.HIGH) || '{}';\n  const mode = block.getFieldValue('MODE') || 'SET';\n  const where = block.getFieldValue('WHERE') || 'FROM_START';\n  const at = generator.valueToCode(block, 'AT', Order.ADDITIVE) || '1';\n  const value = generator.valueToCode(block, 'TO', Order.NONE) || 'Nil';\n\n  let code = '';\n  // If `list` would be evaluated more than once (which is the case for LAST,\n  // FROM_END, and RANDOM) and is non-trivial, make sure to access it only once.\n  if (\n    (where === 'LAST' || where === 'FROM_END' || where === 'RANDOM') &&\n    !list.match(/^\\w+$/)\n  ) {\n    // `list` is an expression, so we may not evaluate it more than once.\n    // We can use multiple statements.\n    const listVar = generator.nameDB_!.getDistinctName(\n      'tmp_list',\n      NameType.VARIABLE,\n    );\n    code = listVar + ' = ' + list + '\\n';\n    list = listVar;\n  }\n  if (mode === 'SET') {\n    code += list + '[' + getListIndex(list, where, at) + '] = ' + value;\n  } else {\n    // `mode` === 'INSERT'\n    // LAST is a special case, because we want to insert\n    // *after* not *before*, the existing last element.\n    code +=\n      'table.insert(' +\n      list +\n      ', ' +\n      (getListIndex(list, where, at) + (where === 'LAST' ? ' + 1' : '')) +\n      ', ' +\n      value +\n      ')';\n  }\n  return code + '\\n';\n}\n\nexport function lists_getSublist(\n  block: Block,\n  generator: LuaGenerator,\n): [string, Order] {\n  // Get sublist.\n  const list = generator.valueToCode(block, 'LIST', Order.NONE) || '{}';\n  const where1 = block.getFieldValue('WHERE1');\n  const where2 = block.getFieldValue('WHERE2');\n  const at1 = generator.valueToCode(block, 'AT1', Order.NONE) || '1';\n  const at2 = generator.valueToCode(block, 'AT2', Order.NONE) || '1';\n\n  // The value for 'FROM_END' and'FROM_START' depends on `at` so\n  // we add it as a parameter.\n  const at1Param =\n    where1 === 'FROM_END' || where1 === 'FROM_START' ? ', at1' : '';\n  const at2Param =\n    where2 === 'FROM_END' || where2 === 'FROM_START' ? ', at2' : '';\n  const functionName = generator.provideFunction_(\n    'list_sublist_' + where1.toLowerCase() + '_' + where2.toLowerCase(),\n    `\nfunction ${generator.FUNCTION_NAME_PLACEHOLDER_}(source${at1Param}${at2Param})\n  local t = {}\n  local start = ${getListIndex('source', where1, 'at1')}\n  local finish = ${getListIndex('source', where2, 'at2')}\n  for i = start, finish do\n    table.insert(t, source[i])\n  end\n  return t\nend\n`,\n  );\n  const code =\n    functionName +\n    '(' +\n    list +\n    // The value for 'FROM_END' and 'FROM_START' depends on `at` so we\n    // pass it.\n    (where1 === 'FROM_END' || where1 === 'FROM_START' ? ', ' + at1 : '') +\n    (where2 === 'FROM_END' || where2 === 'FROM_START' ? ', ' + at2 : '') +\n    ')';\n  return [code, Order.HIGH];\n}\n\nexport function lists_sort(\n  block: Block,\n  generator: LuaGenerator,\n): [string, Order] {\n  // Block for sorting a list.\n  const list = generator.valueToCode(block, 'LIST', Order.NONE) || '{}';\n  const direction = block.getFieldValue('DIRECTION') === '1' ? 1 : -1;\n  const type = block.getFieldValue('TYPE');\n\n  const functionName = generator.provideFunction_(\n    'list_sort',\n    `\nfunction ${generator.FUNCTION_NAME_PLACEHOLDER_}(list, typev, direction)\n  local t = {}\n  for n,v in pairs(list) do table.insert(t, v) end\n  local compareFuncs = {\n    NUMERIC = function(a, b)\n      return (tonumber(tostring(a)) or 0)\n          < (tonumber(tostring(b)) or 0) end,\n    TEXT = function(a, b)\n      return tostring(a) < tostring(b) end,\n    IGNORE_CASE = function(a, b)\n      return string.lower(tostring(a)) < string.lower(tostring(b)) end\n  }\n  local compareTemp = compareFuncs[typev]\n  local compare = compareTemp\n  if direction == -1\n  then compare = function(a, b) return compareTemp(b, a) end\n  end\n  table.sort(t, compare)\n  return t\nend\n`,\n  );\n\n  const code =\n    functionName + '(' + list + ',\"' + type + '\", ' + direction + ')';\n  return [code, Order.HIGH];\n}\n\nexport function lists_split(\n  block: Block,\n  generator: LuaGenerator,\n): [string, Order] {\n  // Block for splitting text into a list, or joining a list into text.\n  let input = generator.valueToCode(block, 'INPUT', Order.NONE);\n  const delimiter = generator.valueToCode(block, 'DELIM', Order.NONE) || \"''\";\n  const mode = block.getFieldValue('MODE');\n  let functionName;\n  if (mode === 'SPLIT') {\n    if (!input) {\n      input = \"''\";\n    }\n    functionName = generator.provideFunction_(\n      'list_string_split',\n      `\nfunction ${generator.FUNCTION_NAME_PLACEHOLDER_}(input, delim)\n  local t = {}\n  local pos = 1\n  while true do\n    next_delim = string.find(input, delim, pos)\n    if next_delim == nil then\n      table.insert(t, string.sub(input, pos))\n      break\n    else\n      table.insert(t, string.sub(input, pos, next_delim-1))\n      pos = next_delim + #delim\n    end\n  end\n  return t\nend\n`,\n    );\n  } else if (mode === 'JOIN') {\n    if (!input) {\n      input = '{}';\n    }\n    functionName = 'table.concat';\n  } else {\n    throw Error('Unknown mode: ' + mode);\n  }\n  const code = functionName + '(' + input + ', ' + delimiter + ')';\n  return [code, Order.HIGH];\n}\n\nexport function lists_reverse(\n  block: Block,\n  generator: LuaGenerator,\n): [string, Order] {\n  // Block for reversing a list.\n  const list = generator.valueToCode(block, 'LIST', Order.NONE) || '{}';\n  const functionName = generator.provideFunction_(\n    'list_reverse',\n    `\nfunction ${generator.FUNCTION_NAME_PLACEHOLDER_}(input)\n  local reversed = {}\n  for i = #input, 1, -1 do\n    table.insert(reversed, input[i])\n  end\n  return reversed\nend\n`,\n  );\n  const code = functionName + '(' + list + ')';\n  return [code, Order.HIGH];\n}\n", "/**\n * @license\n * Copyright 2016 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\n/**\n * @file Generating Lua for logic blocks.\n */\n\n// Former goog.module ID: Blockly.Lua.logic\n\nimport type {Block} from '../../core/block.js';\nimport type {LuaGenerator} from './lua_generator.js';\nimport {Order} from './lua_generator.js';\n\nexport function controls_if(block: Block, generator: LuaGenerator): string {\n  // If/elseif/else condition.\n  let n = 0;\n  let code = '';\n  if (generator.STATEMENT_PREFIX) {\n    // Automatic prefix insertion is switched off for this block.  Add manually.\n    code += generator.injectId(generator.STATEMENT_PREFIX, block);\n  }\n  do {\n    const conditionCode =\n      generator.valueToCode(block, 'IF' + n, Order.NONE) || 'false';\n    let branchCode = generator.statementToCode(block, 'DO' + n);\n    if (generator.STATEMENT_SUFFIX) {\n      branchCode =\n        generator.prefixLines(\n          generator.injectId(generator.STATEMENT_SUFFIX, block),\n          generator.INDENT,\n        ) + branchCode;\n    }\n    code +=\n      (n > 0 ? 'else' : '') + 'if ' + conditionCode + ' then\\n' + branchCode;\n    n++;\n  } while (block.getInput('IF' + n));\n\n  if (block.getInput('ELSE') || generator.STATEMENT_SUFFIX) {\n    let branchCode = block.getInput('ELSE')\n      ? generator.statementToCode(block, 'ELSE')\n      : '';\n    if (generator.STATEMENT_SUFFIX) {\n      branchCode =\n        generator.prefixLines(\n          generator.injectId(generator.STATEMENT_SUFFIX, block),\n          generator.INDENT,\n        ) + branchCode;\n    }\n    code += 'else\\n' + branchCode;\n  }\n  return code + 'end\\n';\n}\n\nexport const controls_ifelse = controls_if;\n\nexport function logic_compare(\n  block: Block,\n  generator: LuaGenerator,\n): [string, Order] {\n  // Comparison operator.\n  const OPERATORS = {\n    'EQ': '==',\n    'NEQ': '~=',\n    'LT': '<',\n    'LTE': '<=',\n    'GT': '>',\n    'GTE': '>=',\n  };\n  type OperatorOption = keyof typeof OPERATORS;\n  const operator = OPERATORS[block.getFieldValue('OP') as OperatorOption];\n  const argument0 = generator.valueToCode(block, 'A', Order.RELATIONAL) || '0';\n  const argument1 = generator.valueToCode(block, 'B', Order.RELATIONAL) || '0';\n  const code = argument0 + ' ' + operator + ' ' + argument1;\n  return [code, Order.RELATIONAL];\n}\n\nexport function logic_operation(\n  block: Block,\n  generator: LuaGenerator,\n): [string, Order] {\n  // Operations 'and', 'or'.\n  const operator = block.getFieldValue('OP') === 'AND' ? 'and' : 'or';\n  const order = operator === 'and' ? Order.AND : Order.OR;\n  let argument0 = generator.valueToCode(block, 'A', order);\n  let argument1 = generator.valueToCode(block, 'B', order);\n  if (!argument0 && !argument1) {\n    // If there are no arguments, then the return value is false.\n    argument0 = 'false';\n    argument1 = 'false';\n  } else {\n    // Single missing arguments have no effect on the return value.\n    const defaultArgument = operator === 'and' ? 'true' : 'false';\n    if (!argument0) {\n      argument0 = defaultArgument;\n    }\n    if (!argument1) {\n      argument1 = defaultArgument;\n    }\n  }\n  const code = argument0 + ' ' + operator + ' ' + argument1;\n  return [code, order];\n}\n\nexport function logic_negate(\n  block: Block,\n  generator: LuaGenerator,\n): [string, Order] {\n  // Negation.\n  const argument0 = generator.valueToCode(block, 'BOOL', Order.UNARY) || 'true';\n  const code = 'not ' + argument0;\n  return [code, Order.UNARY];\n}\n\nexport function logic_boolean(\n  block: Block,\n  generator: LuaGenerator,\n): [string, Order] {\n  // Boolean values true and false.\n  const code = block.getFieldValue('BOOL') === 'TRUE' ? 'true' : 'false';\n  return [code, Order.ATOMIC];\n}\n\nexport function logic_null(\n  block: Block,\n  generator: LuaGenerator,\n): [string, Order] {\n  // Null data type.\n  return ['nil', Order.ATOMIC];\n}\n\nexport function logic_ternary(\n  block: Block,\n  generator: LuaGenerator,\n): [string, Order] {\n  // Ternary operator.\n  const value_if = generator.valueToCode(block, 'IF', Order.AND) || 'false';\n  const value_then = generator.valueToCode(block, 'THEN', Order.AND) || 'nil';\n  const value_else = generator.valueToCode(block, 'ELSE', Order.OR) || 'nil';\n  const code = value_if + ' and ' + value_then + ' or ' + value_else;\n  return [code, Order.OR];\n}\n", "/**\n * @license\n * Copyright 2016 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\n/**\n * @file Generating Lua for loop blocks.\n */\n\n// Former goog.module ID: Blockly.Lua.loops\n\nimport type {ControlFlowInLoopBlock} from '../../blocks/loops.js';\nimport type {Block} from '../../core/block.js';\nimport {NameType} from '../../core/names.js';\nimport * as stringUtils from '../../core/utils/string.js';\nimport type {LuaGenerator} from './lua_generator.js';\nimport {Order} from './lua_generator.js';\n\n/**\n * This is the text used to implement a <pre>continue</pre>.\n * It is also used to recognise <pre>continue</pre>s in generated code so that\n * the appropriate label can be put at the end of the loop body.\n */\nconst CONTINUE_STATEMENT = 'goto continue\\n';\n\n/**\n * If the loop body contains a \"goto continue\" statement, add a continue label\n * to the loop body. Slightly inefficient, as continue labels will be generated\n * in all outer loops, but this is safer than duplicating the logic of\n * blockToCode.\n *\n * @param branch Generated code of the loop body\n * @param indent Whitespace by which to indent a continue statement.\n * @returns Generated label or '' if unnecessary\n */\nfunction addContinueLabel(branch: string, indent: string): string {\n  if (branch.includes(CONTINUE_STATEMENT)) {\n    // False positives are possible (e.g. a string literal), but are harmless.\n    return branch + indent + '::continue::\\n';\n  } else {\n    return branch;\n  }\n}\n\nexport function controls_repeat_ext(\n  block: Block,\n  generator: LuaGenerator,\n): string {\n  // Repeat n times.\n  let repeats;\n  if (block.getField('TIMES')) {\n    // Internal number.\n    repeats = String(Number(block.getFieldValue('TIMES')));\n  } else {\n    // External number.\n    repeats = generator.valueToCode(block, 'TIMES', Order.NONE) || '0';\n  }\n  if (stringUtils.isNumber(repeats)) {\n    repeats = parseInt(repeats, 10);\n  } else {\n    repeats = 'math.floor(' + repeats + ')';\n  }\n  let branch = generator.statementToCode(block, 'DO');\n  branch = generator.addLoopTrap(branch, block);\n  branch = addContinueLabel(branch, generator.INDENT);\n  const loopVar = generator.nameDB_!.getDistinctName(\n    'count',\n    NameType.VARIABLE,\n  );\n  const code =\n    'for ' + loopVar + ' = 1, ' + repeats + ' do\\n' + branch + 'end\\n';\n  return code;\n}\n\nexport const controls_repeat = controls_repeat_ext;\n\nexport function controls_whileUntil(\n  block: Block,\n  generator: LuaGenerator,\n): string {\n  // Do while/until loop.\n  const until = block.getFieldValue('MODE') === 'UNTIL';\n  let argument0 =\n    generator.valueToCode(block, 'BOOL', until ? Order.UNARY : Order.NONE) ||\n    'false';\n  let branch = generator.statementToCode(block, 'DO');\n  branch = generator.addLoopTrap(branch, block);\n  branch = addContinueLabel(branch, generator.INDENT);\n  if (until) {\n    argument0 = 'not ' + argument0;\n  }\n  return 'while ' + argument0 + ' do\\n' + branch + 'end\\n';\n}\n\nexport function controls_for(block: Block, generator: LuaGenerator): string {\n  // For loop.\n  const variable0 = generator.getVariableName(block.getFieldValue('VAR'));\n  const startVar = generator.valueToCode(block, 'FROM', Order.NONE) || '0';\n  const endVar = generator.valueToCode(block, 'TO', Order.NONE) || '0';\n  const increment = generator.valueToCode(block, 'BY', Order.NONE) || '1';\n  let branch = generator.statementToCode(block, 'DO');\n  branch = generator.addLoopTrap(branch, block);\n  branch = addContinueLabel(branch, generator.INDENT);\n  let code = '';\n  let incValue;\n  if (\n    stringUtils.isNumber(startVar) &&\n    stringUtils.isNumber(endVar) &&\n    stringUtils.isNumber(increment)\n  ) {\n    // All arguments are simple numbers.\n    const up = Number(startVar) <= Number(endVar);\n    const step = Math.abs(Number(increment));\n    incValue = (up ? '' : '-') + step;\n  } else {\n    code = '';\n    // Determine loop direction at start, in case one of the bounds\n    // changes during loop execution.\n    incValue = generator.nameDB_!.getDistinctName(\n      variable0 + '_inc',\n      NameType.VARIABLE,\n    );\n    code += incValue + ' = ';\n    if (stringUtils.isNumber(increment)) {\n      code += Math.abs(increment as unknown as number) + '\\n';\n    } else {\n      code += 'math.abs(' + increment + ')\\n';\n    }\n    code += 'if (' + startVar + ') > (' + endVar + ') then\\n';\n    code += generator.INDENT + incValue + ' = -' + incValue + '\\n';\n    code += 'end\\n';\n  }\n  code +=\n    'for ' + variable0 + ' = ' + startVar + ', ' + endVar + ', ' + incValue;\n  code += ' do\\n' + branch + 'end\\n';\n  return code;\n}\n\nexport function controls_forEach(\n  block: Block,\n  generator: LuaGenerator,\n): string {\n  // For each loop.\n  const variable0 = generator.getVariableName(block.getFieldValue('VAR'));\n  const argument0 = generator.valueToCode(block, 'LIST', Order.NONE) || '{}';\n  let branch = generator.statementToCode(block, 'DO');\n  branch = generator.addLoopTrap(branch, block);\n  branch = addContinueLabel(branch, generator.INDENT);\n  const code =\n    'for _, ' +\n    variable0 +\n    ' in ipairs(' +\n    argument0 +\n    ') do \\n' +\n    branch +\n    'end\\n';\n  return code;\n}\n\nexport function controls_flow_statements(\n  block: Block,\n  generator: LuaGenerator,\n): string {\n  // Flow statements: continue, break.\n  let xfix = '';\n  if (generator.STATEMENT_PREFIX) {\n    // Automatic prefix insertion is switched off for this block.  Add manually.\n    xfix += generator.injectId(generator.STATEMENT_PREFIX, block);\n  }\n  if (generator.STATEMENT_SUFFIX) {\n    // Inject any statement suffix here since the regular one at the end\n    // will not get executed if the break/continue is triggered.\n    xfix += generator.injectId(generator.STATEMENT_SUFFIX, block);\n  }\n  if (generator.STATEMENT_PREFIX) {\n    const loop = (block as ControlFlowInLoopBlock).getSurroundLoop();\n    if (loop && !loop.suppressPrefixSuffix) {\n      // Inject loop's statement prefix here since the regular one at the end\n      // of the loop will not get executed if 'continue' is triggered.\n      // In the case of 'break', a prefix is needed due to the loop's suffix.\n      xfix += generator.injectId(generator.STATEMENT_PREFIX, loop);\n    }\n  }\n  switch (block.getFieldValue('FLOW')) {\n    case 'BREAK':\n      return xfix + 'break\\n';\n    case 'CONTINUE':\n      return xfix + CONTINUE_STATEMENT;\n  }\n  throw Error('Unknown flow statement.');\n}\n", "/**\n * @license\n * Copyright 2016 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\n/**\n * @file Generating Lua for math blocks.\n */\n\n// Former goog.module ID: Blockly.Lua.math\n\nimport type {Block} from '../../core/block.js';\nimport type {LuaGenerator} from './lua_generator.js';\nimport {Order} from './lua_generator.js';\n\nexport function math_number(\n  block: Block,\n  generator: LuaGenerator,\n): [string, Order] {\n  // Numeric value.\n  const code = Number(block.getFieldValue('NUM'));\n  const order = code < 0 ? Order.UNARY : Order.ATOMIC;\n  return [String(code), order];\n}\n\nexport function math_arithmetic(\n  block: Block,\n  generator: LuaGenerator,\n): [string, Order] {\n  // Basic arithmetic operators, and power.\n  const OPERATORS: Record<string, [string, Order]> = {\n    'ADD': [' + ', Order.ADDITIVE],\n    'MINUS': [' - ', Order.ADDITIVE],\n    'MULTIPLY': [' * ', Order.MULTIPLICATIVE],\n    'DIVIDE': [' / ', Order.MULTIPLICATIVE],\n    'POWER': [' ^ ', Order.EXPONENTIATION],\n  };\n  type OperatorOption = keyof typeof OPERATORS;\n  const tuple = OPERATORS[block.getFieldValue('OP') as OperatorOption];\n  const operator = tuple[0];\n  const order = tuple[1];\n  const argument0 = generator.valueToCode(block, 'A', order) || '0';\n  const argument1 = generator.valueToCode(block, 'B', order) || '0';\n  const code = argument0 + operator + argument1;\n  return [code, order];\n}\n\nexport function math_single(\n  block: Block,\n  generator: LuaGenerator,\n): [string, Order] {\n  // Math operators with single operand.\n  const operator = block.getFieldValue('OP');\n  let arg;\n  if (operator === 'NEG') {\n    // Negation is a special case given its different operator precedence.\n    arg = generator.valueToCode(block, 'NUM', Order.UNARY) || '0';\n    return ['-' + arg, Order.UNARY];\n  }\n  if (operator === 'POW10') {\n    arg = generator.valueToCode(block, 'NUM', Order.EXPONENTIATION) || '0';\n    return ['10 ^ ' + arg, Order.EXPONENTIATION];\n  }\n  if (operator === 'ROUND') {\n    arg = generator.valueToCode(block, 'NUM', Order.ADDITIVE) || '0';\n  } else {\n    arg = generator.valueToCode(block, 'NUM', Order.NONE) || '0';\n  }\n\n  let code;\n  switch (operator) {\n    case 'ABS':\n      code = 'math.abs(' + arg + ')';\n      break;\n    case 'ROOT':\n      code = 'math.sqrt(' + arg + ')';\n      break;\n    case 'LN':\n      code = 'math.log(' + arg + ')';\n      break;\n    case 'LOG10':\n      code = 'math.log(' + arg + ', 10)';\n      break;\n    case 'EXP':\n      code = 'math.exp(' + arg + ')';\n      break;\n    case 'ROUND':\n      // This rounds up.  Blockly does not specify rounding direction.\n      code = 'math.floor(' + arg + ' + .5)';\n      break;\n    case 'ROUNDUP':\n      code = 'math.ceil(' + arg + ')';\n      break;\n    case 'ROUNDDOWN':\n      code = 'math.floor(' + arg + ')';\n      break;\n    case 'SIN':\n      code = 'math.sin(math.rad(' + arg + '))';\n      break;\n    case 'COS':\n      code = 'math.cos(math.rad(' + arg + '))';\n      break;\n    case 'TAN':\n      code = 'math.tan(math.rad(' + arg + '))';\n      break;\n    case 'ASIN':\n      code = 'math.deg(math.asin(' + arg + '))';\n      break;\n    case 'ACOS':\n      code = 'math.deg(math.acos(' + arg + '))';\n      break;\n    case 'ATAN':\n      code = 'math.deg(math.atan(' + arg + '))';\n      break;\n    default:\n      throw Error('Unknown math operator: ' + operator);\n  }\n  return [code, Order.HIGH];\n}\n\nexport function math_constant(\n  block: Block,\n  generator: LuaGenerator,\n): [string, Order] {\n  // Constants: PI, E, the Golden Ratio, sqrt(2), 1/sqrt(2), INFINITY.\n  const CONSTANTS: Record<string, [string, Order]> = {\n    'PI': ['math.pi', Order.HIGH],\n    'E': ['math.exp(1)', Order.HIGH],\n    'GOLDEN_RATIO': ['(1 + math.sqrt(5)) / 2', Order.MULTIPLICATIVE],\n    'SQRT2': ['math.sqrt(2)', Order.HIGH],\n    'SQRT1_2': ['math.sqrt(1 / 2)', Order.HIGH],\n    'INFINITY': ['math.huge', Order.HIGH],\n  };\n  return CONSTANTS[block.getFieldValue('CONSTANT')];\n}\n\nexport function math_number_property(\n  block: Block,\n  generator: LuaGenerator,\n): [string, Order] {\n  // Check if a number is even, odd, prime, whole, positive, or negative\n  // or if it is divisible by certain number. Returns true or false.\n  const PROPERTIES: Record<string, [string | null, Order, Order]> = {\n    'EVEN': [' % 2 == 0', Order.MULTIPLICATIVE, Order.RELATIONAL],\n    'ODD': [' % 2 == 1', Order.MULTIPLICATIVE, Order.RELATIONAL],\n    'WHOLE': [' % 1 == 0', Order.MULTIPLICATIVE, Order.RELATIONAL],\n    'POSITIVE': [' > 0', Order.RELATIONAL, Order.RELATIONAL],\n    'NEGATIVE': [' < 0', Order.RELATIONAL, Order.RELATIONAL],\n    'DIVISIBLE_BY': [null, Order.MULTIPLICATIVE, Order.RELATIONAL],\n    'PRIME': [null, Order.NONE, Order.HIGH],\n  };\n  const dropdownProperty = block.getFieldValue('PROPERTY');\n  const [suffix, inputOrder, outputOrder] = PROPERTIES[dropdownProperty];\n  const numberToCheck =\n    generator.valueToCode(block, 'NUMBER_TO_CHECK', inputOrder) || '0';\n  let code;\n  if (dropdownProperty === 'PRIME') {\n    // Prime is a special case as it is not a one-liner test.\n    const functionName = generator.provideFunction_(\n      'math_isPrime',\n      `\nfunction ${generator.FUNCTION_NAME_PLACEHOLDER_}(n)\n  -- https://en.wikipedia.org/wiki/Primality_test#Naive_methods\n  if n == 2 or n == 3 then\n    return true\n  end\n  -- False if n is NaN, negative, is 1, or not whole.\n  -- And false if n is divisible by 2 or 3.\n  if not(n > 1) or n % 1 ~= 0 or n % 2 == 0 or n % 3 == 0 then\n    return false\n  end\n  -- Check all the numbers of form 6k +/- 1, up to sqrt(n).\n  for x = 6, math.sqrt(n) + 1.5, 6 do\n    if n % (x - 1) == 0 or n % (x + 1) == 0 then\n      return false\n    end\n  end\n  return true\nend\n`,\n    );\n    code = functionName + '(' + numberToCheck + ')';\n  } else if (dropdownProperty === 'DIVISIBLE_BY') {\n    const divisor =\n      generator.valueToCode(block, 'DIVISOR', Order.MULTIPLICATIVE) || '0';\n    // If 'divisor' is some code that evals to 0, generator will produce a nan.\n    // Let's produce nil if we can determine this at compile-time.\n    if (divisor === '0') {\n      return ['nil', Order.ATOMIC];\n    }\n    // The normal trick to implement ?: with and/or doesn't work here:\n    //   divisor == 0 and nil or number_to_check % divisor == 0\n    // because nil is false, so allow a runtime failure. :-(\n    code = numberToCheck + ' % ' + divisor + ' == 0';\n  } else {\n    code = numberToCheck + suffix;\n  }\n  return [code, outputOrder];\n}\n\nexport function math_change(block: Block, generator: LuaGenerator): string {\n  // Add to a variable in place.\n  const argument0 =\n    generator.valueToCode(block, 'DELTA', Order.ADDITIVE) || '0';\n  const varName = generator.getVariableName(block.getFieldValue('VAR'));\n  return varName + ' = ' + varName + ' + ' + argument0 + '\\n';\n}\n\n// Rounding functions have a single operand.\nexport const math_round = math_single;\n// Trigonometry functions have a single operand.\nexport const math_trig = math_single;\n\nexport function math_on_list(\n  block: Block,\n  generator: LuaGenerator,\n): [string, Order] {\n  // Math functions for lists.\n  const func = block.getFieldValue('OP');\n  const list = generator.valueToCode(block, 'LIST', Order.NONE) || '{}';\n  let functionName;\n\n  // Functions needed in more than one case.\n  function provideSum() {\n    return generator.provideFunction_(\n      'math_sum',\n      `\nfunction ${generator.FUNCTION_NAME_PLACEHOLDER_}(t)\n  local result = 0\n  for _, v in ipairs(t) do\n    result = result + v\n  end\n  return result\nend\n`,\n    );\n  }\n\n  switch (func) {\n    case 'SUM':\n      functionName = provideSum();\n      break;\n\n    case 'MIN':\n      // Returns 0 for the empty list.\n      functionName = generator.provideFunction_(\n        'math_min',\n        `\nfunction ${generator.FUNCTION_NAME_PLACEHOLDER_}(t)\n  if #t == 0 then\n    return 0\n  end\n  local result = math.huge\n  for _, v in ipairs(t) do\n    if v < result then\n      result = v\n    end\n  end\n  return result\nend\n`,\n      );\n      break;\n\n    case 'AVERAGE':\n      // Returns 0 for the empty list.\n      functionName = generator.provideFunction_(\n        'math_average',\n        `\nfunction ${generator.FUNCTION_NAME_PLACEHOLDER_}(t)\n  if #t == 0 then\n    return 0\n  end\n  return ${provideSum()}(t) / #t\nend\n`,\n      );\n      break;\n\n    case 'MAX':\n      // Returns 0 for the empty list.\n      functionName = generator.provideFunction_(\n        'math_max',\n        `\nfunction ${generator.FUNCTION_NAME_PLACEHOLDER_}(t)\n  if #t == 0 then\n    return 0\n  end\n  local result = -math.huge\n  for _, v in ipairs(t) do\n    if v > result then\n      result = v\n    end\n  end\n  return result\nend\n`,\n      );\n      break;\n\n    case 'MEDIAN':\n      // This operation excludes non-numbers.\n      functionName = generator.provideFunction_(\n        'math_median',\n        `\nfunction ${generator.FUNCTION_NAME_PLACEHOLDER_}(t)\n  -- Source: http://lua-users.org/wiki/SimpleStats\n  if #t == 0 then\n    return 0\n  end\n  local temp = {}\n  for _, v in ipairs(t) do\n    if type(v) == 'number' then\n      table.insert(temp, v)\n    end\n  end\n  table.sort(temp)\n  if #temp % 2 == 0 then\n    return (temp[#temp / 2] + temp[(#temp / 2) + 1]) / 2\n  else\n    return temp[math.ceil(#temp / 2)]\n  end\nend\n`,\n      );\n      break;\n\n    case 'MODE':\n      // As a list of numbers can contain more than one mode,\n      // the returned result is provided as an array.\n      // The generator version includes non-numbers.\n      functionName = generator.provideFunction_(\n        'math_modes',\n        `\nfunction ${generator.FUNCTION_NAME_PLACEHOLDER_}(t)\n  -- Source: http://lua-users.org/wiki/SimpleStats\n  local counts = {}\n  for _, v in ipairs(t) do\n    if counts[v] == nil then\n      counts[v] = 1\n    else\n      counts[v] = counts[v] + 1\n    end\n  end\n  local biggestCount = 0\n  for _, v  in pairs(counts) do\n    if v > biggestCount then\n      biggestCount = v\n    end\n  end\n  local temp = {}\n  for k, v in pairs(counts) do\n    if v == biggestCount then\n      table.insert(temp, k)\n    end\n  end\n  return temp\nend\n`,\n      );\n      break;\n\n    case 'STD_DEV':\n      functionName = generator.provideFunction_(\n        'math_standard_deviation',\n        `\nfunction ${generator.FUNCTION_NAME_PLACEHOLDER_}(t)\n  local m\n  local vm\n  local total = 0\n  local count = 0\n  local result\n  m = #t == 0 and 0 or ${provideSum()}(t) / #t\n  for _, v in ipairs(t) do\n    if type(v) == 'number' then\n      vm = v - m\n      total = total + (vm * vm)\n      count = count + 1\n    end\n  end\n  result = math.sqrt(total / (count-1))\n  return result\nend\n`,\n      );\n      break;\n\n    case 'RANDOM':\n      functionName = generator.provideFunction_(\n        'math_random_list',\n        `\nfunction ${generator.FUNCTION_NAME_PLACEHOLDER_}(t)\n  if #t == 0 then\n    return nil\n  end\n  return t[math.random(#t)]\nend\n`,\n      );\n      break;\n\n    default:\n      throw Error('Unknown operator: ' + func);\n  }\n  return [functionName + '(' + list + ')', Order.HIGH];\n}\n\nexport function math_modulo(\n  block: Block,\n  generator: LuaGenerator,\n): [string, Order] {\n  // Remainder computation.\n  const argument0 =\n    generator.valueToCode(block, 'DIVIDEND', Order.MULTIPLICATIVE) || '0';\n  const argument1 =\n    generator.valueToCode(block, 'DIVISOR', Order.MULTIPLICATIVE) || '0';\n  const code = argument0 + ' % ' + argument1;\n  return [code, Order.MULTIPLICATIVE];\n}\n\nexport function math_constrain(\n  block: Block,\n  generator: LuaGenerator,\n): [string, Order] {\n  // Constrain a number between two limits.\n  const argument0 = generator.valueToCode(block, 'VALUE', Order.NONE) || '0';\n  const argument1 =\n    generator.valueToCode(block, 'LOW', Order.NONE) || '-math.huge';\n  const argument2 =\n    generator.valueToCode(block, 'HIGH', Order.NONE) || 'math.huge';\n  const code =\n    'math.min(math.max(' +\n    argument0 +\n    ', ' +\n    argument1 +\n    '), ' +\n    argument2 +\n    ')';\n  return [code, Order.HIGH];\n}\n\nexport function math_random_int(\n  block: Block,\n  generator: LuaGenerator,\n): [string, Order] {\n  // Random integer between [X] and [Y].\n  const argument0 = generator.valueToCode(block, 'FROM', Order.NONE) || '0';\n  const argument1 = generator.valueToCode(block, 'TO', Order.NONE) || '0';\n  const code = 'math.random(' + argument0 + ', ' + argument1 + ')';\n  return [code, Order.HIGH];\n}\n\nexport function math_random_float(\n  block: Block,\n  generator: LuaGenerator,\n): [string, Order] {\n  // Random fraction between 0 and 1.\n  return ['math.random()', Order.HIGH];\n}\n\nexport function math_atan2(\n  block: Block,\n  generator: LuaGenerator,\n): [string, Order] {\n  // Arctangent of point (X, Y) in degrees from -180 to 180.\n  const argument0 = generator.valueToCode(block, 'X', Order.NONE) || '0';\n  const argument1 = generator.valueToCode(block, 'Y', Order.NONE) || '0';\n  return [\n    'math.deg(math.atan2(' + argument1 + ', ' + argument0 + '))',\n    Order.HIGH,\n  ];\n}\n", "/**\n * @license\n * Copyright 2016 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\n/**\n * @file Generating Lua for procedure blocks.\n */\n\n// Former goog.module ID: Blockly.Lua.procedures\n\nimport type {IfReturnBlock} from '../../blocks/procedures.js';\nimport type {Block} from '../../core/block.js';\nimport type {LuaGenerator} from './lua_generator.js';\nimport {Order} from './lua_generator.js';\n\nexport function procedures_defreturn(\n  block: Block,\n  generator: LuaGenerator,\n): null {\n  // Define a procedure with a return value.\n  const funcName = generator.getProcedureName(block.getFieldValue('NAME'));\n  let xfix1 = '';\n  if (generator.STATEMENT_PREFIX) {\n    xfix1 += generator.injectId(generator.STATEMENT_PREFIX, block);\n  }\n  if (generator.STATEMENT_SUFFIX) {\n    xfix1 += generator.injectId(generator.STATEMENT_SUFFIX, block);\n  }\n  if (xfix1) {\n    xfix1 = generator.prefixLines(xfix1, generator.INDENT);\n  }\n  let loopTrap = '';\n  if (generator.INFINITE_LOOP_TRAP) {\n    loopTrap = generator.prefixLines(\n      generator.injectId(generator.INFINITE_LOOP_TRAP, block),\n      generator.INDENT,\n    );\n  }\n  let branch = '';\n  if (block.getInput('STACK')) {\n    // The 'procedures_defreturn' block might not have a STACK input.\n    branch = generator.statementToCode(block, 'STACK');\n  }\n  let returnValue = '';\n  if (block.getInput('RETURN')) {\n    // The 'procedures_defnoreturn' block (which shares this code)\n    // does not have a RETURN input.\n    returnValue = generator.valueToCode(block, 'RETURN', Order.NONE) || '';\n  }\n  let xfix2 = '';\n  if (branch && returnValue) {\n    // After executing the function body, revisit this block for the return.\n    xfix2 = xfix1;\n  }\n  if (returnValue) {\n    returnValue = generator.INDENT + 'return ' + returnValue + '\\n';\n  } else if (!branch) {\n    branch = '';\n  }\n  const args = [];\n  const variables = block.getVars();\n  for (let i = 0; i < variables.length; i++) {\n    args[i] = generator.getVariableName(variables[i]);\n  }\n  let code =\n    'function ' +\n    funcName +\n    '(' +\n    args.join(', ') +\n    ')\\n' +\n    xfix1 +\n    loopTrap +\n    branch +\n    xfix2 +\n    returnValue +\n    'end\\n';\n  code = generator.scrub_(block, code);\n  // Add % so as not to collide with helper functions in definitions list.\n  // TODO(#7600): find better approach than casting to any to override\n  // CodeGenerator declaring .definitions protected.\n  (generator as AnyDuringMigration).definitions_['%' + funcName] = code;\n  return null;\n}\n\n// Defining a procedure without a return value uses the same generator as\n// a procedure with a return value.\nexport const procedures_defnoreturn = procedures_defreturn;\n\nexport function procedures_callreturn(\n  block: Block,\n  generator: LuaGenerator,\n): [string, Order] {\n  // Call a procedure with a return value.\n  const funcName = generator.getProcedureName(block.getFieldValue('NAME'));\n  const args = [];\n  const variables = block.getVars();\n  for (let i = 0; i < variables.length; i++) {\n    args[i] = generator.valueToCode(block, 'ARG' + i, Order.NONE) || 'nil';\n  }\n  const code = funcName + '(' + args.join(', ') + ')';\n  return [code, Order.HIGH];\n}\n\nexport function procedures_callnoreturn(\n  block: Block,\n  generator: LuaGenerator,\n): string {\n  // Call a procedure with no return value.\n  // Generated code is for a function call as a statement is the same as a\n  // function call as a value, with the addition of line ending.\n  const tuple = generator.forBlock['procedures_callreturn'](\n    block,\n    generator,\n  ) as [string, number];\n  return tuple[0] + '\\n';\n}\n\nexport function procedures_ifreturn(\n  block: Block,\n  generator: LuaGenerator,\n): string {\n  // Conditionally return value from a procedure.\n  const condition =\n    generator.valueToCode(block, 'CONDITION', Order.NONE) || 'false';\n  let code = 'if ' + condition + ' then\\n';\n  if (generator.STATEMENT_SUFFIX) {\n    // Inject any statement suffix here since the regular one at the end\n    // will not get executed if the return is triggered.\n    code += generator.prefixLines(\n      generator.injectId(generator.STATEMENT_SUFFIX, block),\n      generator.INDENT,\n    );\n  }\n  if ((block as IfReturnBlock).hasReturnValue_) {\n    const value = generator.valueToCode(block, 'VALUE', Order.NONE) || 'nil';\n    code += generator.INDENT + 'return ' + value + '\\n';\n  } else {\n    code += generator.INDENT + 'return\\n';\n  }\n  code += 'end\\n';\n  return code;\n}\n", "/**\n * @license\n * Copyright 2016 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\n/**\n * @file Generating Lua for text blocks.\n */\n\n// Former goog.module ID: Blockly.Lua.texts\n\nimport type {JoinMutatorBlock} from '../../blocks/text.js';\nimport type {Block} from '../../core/block.js';\nimport type {LuaGenerator} from './lua_generator.js';\nimport {Order} from './lua_generator.js';\n\nexport function text(block: Block, generator: LuaGenerator): [string, Order] {\n  // Text value.\n  const code = generator.quote_(block.getFieldValue('TEXT'));\n  return [code, Order.ATOMIC];\n}\n\nexport function text_join(\n  block: Block,\n  generator: LuaGenerator,\n): [string, Order] {\n  const joinBlock = block as JoinMutatorBlock;\n  // Create a string made up of any number of elements of any type.\n  if (joinBlock.itemCount_ === 0) {\n    return [\"''\", Order.ATOMIC];\n  } else if (joinBlock.itemCount_ === 1) {\n    const element = generator.valueToCode(block, 'ADD0', Order.NONE) || \"''\";\n    const code = 'tostring(' + element + ')';\n    return [code, Order.HIGH];\n  } else if (joinBlock.itemCount_ === 2) {\n    const element0 =\n      generator.valueToCode(block, 'ADD0', Order.CONCATENATION) || \"''\";\n    const element1 =\n      generator.valueToCode(block, 'ADD1', Order.CONCATENATION) || \"''\";\n    const code = element0 + ' .. ' + element1;\n    return [code, Order.CONCATENATION];\n  } else {\n    const elements = [];\n    for (let i = 0; i < joinBlock.itemCount_; i++) {\n      elements[i] = generator.valueToCode(block, 'ADD' + i, Order.NONE) || \"''\";\n    }\n    const code = 'table.concat({' + elements.join(', ') + '})';\n    return [code, Order.HIGH];\n  }\n}\n\nexport function text_append(block: Block, generator: LuaGenerator): string {\n  // Append to a variable in place.\n  const varName = generator.getVariableName(block.getFieldValue('VAR'));\n  const value =\n    generator.valueToCode(block, 'TEXT', Order.CONCATENATION) || \"''\";\n  return varName + ' = ' + varName + ' .. ' + value + '\\n';\n}\n\nexport function text_length(\n  block: Block,\n  generator: LuaGenerator,\n): [string, Order] {\n  // String or array length.\n  const text = generator.valueToCode(block, 'VALUE', Order.UNARY) || \"''\";\n  return ['#' + text, Order.UNARY];\n}\n\nexport function text_isEmpty(\n  block: Block,\n  generator: LuaGenerator,\n): [string, Order] {\n  // Is the string null or array empty?\n  const text = generator.valueToCode(block, 'VALUE', Order.UNARY) || \"''\";\n  return ['#' + text + ' == 0', Order.RELATIONAL];\n}\n\nexport function text_indexOf(\n  block: Block,\n  generator: LuaGenerator,\n): [string, Order] {\n  // Search the text for a substring.\n  const substring = generator.valueToCode(block, 'FIND', Order.NONE) || \"''\";\n  const text = generator.valueToCode(block, 'VALUE', Order.NONE) || \"''\";\n  let functionName;\n  if (block.getFieldValue('END') === 'FIRST') {\n    functionName = generator.provideFunction_(\n      'firstIndexOf',\n      `\nfunction ${generator.FUNCTION_NAME_PLACEHOLDER_}(str, substr)\n  local i = string.find(str, substr, 1, true)\n  if i == nil then\n    return 0\n  end\n  return i\nend\n`,\n    );\n  } else {\n    functionName = generator.provideFunction_(\n      'lastIndexOf',\n      `\nfunction ${generator.FUNCTION_NAME_PLACEHOLDER_}(str, substr)\n  local i = string.find(string.reverse(str), string.reverse(substr), 1, true)\n  if i then\n    return #str + 2 - i - #substr\n  end\n  return 0\nend\n`,\n    );\n  }\n  const code = functionName + '(' + text + ', ' + substring + ')';\n  return [code, Order.HIGH];\n}\n\nexport function text_charAt(\n  block: Block,\n  generator: LuaGenerator,\n): [string, Order] {\n  // Get letter at index.\n  // Note: Until January 2013 this block did not have the WHERE input.\n  const where = block.getFieldValue('WHERE') || 'FROM_START';\n  const text = generator.valueToCode(block, 'VALUE', Order.NONE) || \"''\";\n  let code;\n  if (where === 'RANDOM') {\n    const functionName = generator.provideFunction_(\n      'text_random_letter',\n      `\nfunction ${generator.FUNCTION_NAME_PLACEHOLDER_}(str)\n  local index = math.random(string.len(str))\n  return string.sub(str, index, index)\nend\n`,\n    );\n    code = functionName + '(' + text + ')';\n  } else {\n    let start;\n    if (where === 'FIRST') {\n      start = '1';\n    } else if (where === 'LAST') {\n      start = '-1';\n    } else {\n      const atOrder = where === 'FROM_END' ? Order.UNARY : Order.NONE;\n      const at = generator.valueToCode(block, 'AT', atOrder) || '1';\n      if (where === 'FROM_START') {\n        start = at;\n      } else if (where === 'FROM_END') {\n        start = '-' + at;\n      } else {\n        throw Error('Unhandled option (text_charAt).');\n      }\n    }\n    if (start.match(/^-?\\w*$/)) {\n      code = 'string.sub(' + text + ', ' + start + ', ' + start + ')';\n    } else {\n      // use function to avoid reevaluation\n      const functionName = generator.provideFunction_(\n        'text_char_at',\n        `\nfunction ${generator.FUNCTION_NAME_PLACEHOLDER_}(str, index)\n  return string.sub(str, index, index)\nend\n`,\n      );\n      code = functionName + '(' + text + ', ' + start + ')';\n    }\n  }\n  return [code, Order.HIGH];\n}\n\nexport function text_getSubstring(\n  block: Block,\n  generator: LuaGenerator,\n): [string, Order] {\n  // Get substring.\n  const text = generator.valueToCode(block, 'STRING', Order.NONE) || \"''\";\n\n  // Get start index.\n  const where1 = block.getFieldValue('WHERE1');\n  const at1Order = where1 === 'FROM_END' ? Order.UNARY : Order.NONE;\n  const at1 = generator.valueToCode(block, 'AT1', at1Order) || '1';\n  let start;\n  if (where1 === 'FIRST') {\n    start = 1;\n  } else if (where1 === 'FROM_START') {\n    start = at1;\n  } else if (where1 === 'FROM_END') {\n    start = '-' + at1;\n  } else {\n    throw Error('Unhandled option (text_getSubstring)');\n  }\n\n  // Get end index.\n  const where2 = block.getFieldValue('WHERE2');\n  const at2Order = where2 === 'FROM_END' ? Order.UNARY : Order.NONE;\n  const at2 = generator.valueToCode(block, 'AT2', at2Order) || '1';\n  let end;\n  if (where2 === 'LAST') {\n    end = -1;\n  } else if (where2 === 'FROM_START') {\n    end = at2;\n  } else if (where2 === 'FROM_END') {\n    end = '-' + at2;\n  } else {\n    throw Error('Unhandled option (text_getSubstring)');\n  }\n  const code = 'string.sub(' + text + ', ' + start + ', ' + end + ')';\n  return [code, Order.HIGH];\n}\n\nexport function text_changeCase(\n  block: Block,\n  generator: LuaGenerator,\n): [string, Order] {\n  // Change capitalization.\n  const operator = block.getFieldValue('CASE');\n  const text = generator.valueToCode(block, 'TEXT', Order.NONE) || \"''\";\n  let functionName;\n  if (operator === 'UPPERCASE') {\n    functionName = 'string.upper';\n  } else if (operator === 'LOWERCASE') {\n    functionName = 'string.lower';\n  } else if (operator === 'TITLECASE') {\n    // There are shorter versions at\n    // http://lua-users.org/wiki/SciteTitleCase\n    // that do not preserve whitespace.\n    functionName = generator.provideFunction_(\n      'text_titlecase',\n      `\nfunction ${generator.FUNCTION_NAME_PLACEHOLDER_}(str)\n  local buf = {}\n  local inWord = false\n  for i = 1, #str do\n    local c = string.sub(str, i, i)\n    if inWord then\n      table.insert(buf, string.lower(c))\n      if string.find(c, \"%s\") then\n        inWord = false\n      end\n    else\n      table.insert(buf, string.upper(c))\n      inWord = true\n    end\n  end\n  return table.concat(buf)\nend\n`,\n    );\n  }\n  const code = functionName + '(' + text + ')';\n  return [code, Order.HIGH];\n}\n\nexport function text_trim(\n  block: Block,\n  generator: LuaGenerator,\n): [string, Order] {\n  // Trim spaces.\n  const OPERATORS = {LEFT: '^%s*(,-)', RIGHT: '(.-)%s*$', BOTH: '^%s*(.-)%s*$'};\n  type OperatorOption = keyof typeof OPERATORS;\n  const operator = OPERATORS[block.getFieldValue('MODE') as OperatorOption];\n  const text = generator.valueToCode(block, 'TEXT', Order.NONE) || \"''\";\n  const code = 'string.gsub(' + text + ', \"' + operator + '\", \"%1\")';\n  return [code, Order.HIGH];\n}\n\nexport function text_print(block: Block, generator: LuaGenerator): string {\n  // Print statement.\n  const msg = generator.valueToCode(block, 'TEXT', Order.NONE) || \"''\";\n  return 'print(' + msg + ')\\n';\n}\n\nexport function text_prompt_ext(\n  block: Block,\n  generator: LuaGenerator,\n): [string, Order] {\n  // Prompt function.\n  let msg;\n  if (block.getField('TEXT')) {\n    // Internal message.\n    msg = generator.quote_(block.getFieldValue('TEXT'));\n  } else {\n    // External message.\n    msg = generator.valueToCode(block, 'TEXT', Order.NONE) || \"''\";\n  }\n\n  const functionName = generator.provideFunction_(\n    'text_prompt',\n    `\nfunction ${generator.FUNCTION_NAME_PLACEHOLDER_}(msg)\n  io.write(msg)\n  io.flush()\n  return io.read()\nend\n`,\n  );\n  let code = functionName + '(' + msg + ')';\n\n  const toNumber = block.getFieldValue('TYPE') === 'NUMBER';\n  if (toNumber) {\n    code = 'tonumber(' + code + ', 10)';\n  }\n  return [code, Order.HIGH];\n}\n\nexport const text_prompt = text_prompt_ext;\n\nexport function text_count(\n  block: Block,\n  generator: LuaGenerator,\n): [string, Order] {\n  const text = generator.valueToCode(block, 'TEXT', Order.NONE) || \"''\";\n  const sub = generator.valueToCode(block, 'SUB', Order.NONE) || \"''\";\n  const functionName = generator.provideFunction_(\n    'text_count',\n    `\nfunction ${generator.FUNCTION_NAME_PLACEHOLDER_}(haystack, needle)\n  if #needle == 0 then\n    return #haystack + 1\n  end\n  local i = 1\n  local count = 0\n  while true do\n    i = string.find(haystack, needle, i, true)\n    if i == nil then\n      break\n    end\n    count = count + 1\n    i = i + #needle\n  end\n  return count\nend\n`,\n  );\n  const code = functionName + '(' + text + ', ' + sub + ')';\n  return [code, Order.HIGH];\n}\n\nexport function text_replace(\n  block: Block,\n  generator: LuaGenerator,\n): [string, Order] {\n  const text = generator.valueToCode(block, 'TEXT', Order.NONE) || \"''\";\n  const from = generator.valueToCode(block, 'FROM', Order.NONE) || \"''\";\n  const to = generator.valueToCode(block, 'TO', Order.NONE) || \"''\";\n  const functionName = generator.provideFunction_(\n    'text_replace',\n    `\nfunction ${generator.FUNCTION_NAME_PLACEHOLDER_}(haystack, needle, replacement)\n  local buf = {}\n  local i = 1\n  while i <= #haystack do\n    if string.sub(haystack, i, i + #needle - 1) == needle then\n      for j = 1, #replacement do\n        table.insert(buf, string.sub(replacement, j, j))\n      end\n      i = i + #needle\n    else\n      table.insert(buf, string.sub(haystack, i, i))\n      i = i + 1\n    end\n  end\n  return table.concat(buf)\nend\n`,\n  );\n  const code = functionName + '(' + text + ', ' + from + ', ' + to + ')';\n  return [code, Order.HIGH];\n}\n\nexport function text_reverse(\n  block: Block,\n  generator: LuaGenerator,\n): [string, Order] {\n  const text = generator.valueToCode(block, 'TEXT', Order.NONE) || \"''\";\n  const code = 'string.reverse(' + text + ')';\n  return [code, Order.HIGH];\n}\n", "/**\n * @license\n * Copyright 2016 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\n/**\n * @file Generating Lua for variable blocks.\n */\n\n// Former goog.module ID: Blockly.Lua.variables\n\nimport type {Block} from '../../core/block.js';\nimport type {LuaGenerator} from './lua_generator.js';\nimport {Order} from './lua_generator.js';\n\nexport function variables_get(\n  block: Block,\n  generator: LuaGenerator,\n): [string, Order] {\n  // Variable getter.\n  const code = generator.getVariableName(block.getFieldValue('VAR'));\n  return [code, Order.ATOMIC];\n}\n\nexport function variables_set(block: Block, generator: LuaGenerator): string {\n  // Variable setter.\n  const argument0 = generator.valueToCode(block, 'VALUE', Order.NONE) || '0';\n  const varName = generator.getVariableName(block.getFieldValue('VAR'));\n  return varName + ' = ' + argument0 + '\\n';\n}\n", "/**\n * @license\n * Copyright 2016 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\n/**\n * @file Lua code generator class, including helper methods for\n * generating Lua for blocks.\n *\n * Based on Ellen Spertus's blocky-lua project.\n */\n\n// Former goog.module ID: Blockly.Lua\n\nimport type {Block} from '../../core/block.js';\nimport {CodeGenerator} from '../../core/generator.js';\nimport {inputTypes} from '../../core/inputs/input_types.js';\nimport {Names} from '../../core/names.js';\nimport * as stringUtils from '../../core/utils/string.js';\nimport type {Workspace} from '../../core/workspace.js';\n\n/**\n * Order of operation ENUMs.\n * http://www.lua.org/manual/5.3/manual.html#3.4.8\n */\n// prettier-ignore\nexport enum Order {\n  ATOMIC = 0,    // literals\n  // The next level was not explicit in documentation and inferred by Ellen.\n  HIGH = 1,            // Function calls, tables[]\n  EXPONENTIATION = 2,  // ^\n  UNARY = 3,           // not # - ~\n  MULTIPLICATIVE = 4,  // * / %\n  ADDITIVE = 5,        // + -\n  CONCATENATION = 6,   // ..\n  RELATIONAL = 7,      // < > <=  >= ~= ==\n  AND = 8,             // and\n  OR = 9,              // or\n  NONE = 99,\n}\n\n/**\n * Lua code generator class.\n *\n * Note: Lua is not supporting zero-indexing since the language itself is\n * one-indexed, so the generator does not repoct the oneBasedIndex configuration\n * option used for lists and text.\n */\nexport class LuaGenerator extends CodeGenerator {\n  constructor(name = 'Lua') {\n    super(name);\n    this.isInitialized = false;\n\n    // Copy Order values onto instance for backwards compatibility\n    // while ensuring they are not part of the publically-advertised\n    // API.\n    //\n    // TODO(#7085): deprecate these in due course.  (Could initially\n    // replace data properties with get accessors that call\n    // deprecate.warn().)\n    for (const key in Order) {\n      // Must assign Order[key] to a temporary to get the type guard to work;\n      // see https://github.com/microsoft/TypeScript/issues/10530.\n      const value = Order[key];\n      // Skip reverse-lookup entries in the enum.  Due to\n      // https://github.com/microsoft/TypeScript/issues/55713 this (as\n      // of TypeScript 5.5.2) actually narrows the type of value to\n      // never - but that still allows the following assignment to\n      // succeed.\n      if (typeof value === 'string') continue;\n      (this as unknown as Record<string, Order>)['ORDER_' + key] = value;\n    }\n\n    // List of illegal variable names.  This is not intended to be a\n    // security feature.  Blockly is 100% client-side, so bypassing\n    // this list is trivial.  This is intended to prevent users from\n    // accidentally clobbering a built-in object or function.\n    this.addReservedWords(\n      // Special character\n      '_,' +\n        // From theoriginalbit's script:\n        // https://github.com/espertus/blockly-lua/issues/6\n        '__inext,assert,bit,colors,colours,coroutine,disk,dofile,error,fs,' +\n        'fetfenv,getmetatable,gps,help,io,ipairs,keys,loadfile,loadstring,math,' +\n        'native,next,os,paintutils,pairs,parallel,pcall,peripheral,print,' +\n        'printError,rawequal,rawget,rawset,read,rednet,redstone,rs,select,' +\n        'setfenv,setmetatable,sleep,string,table,term,textutils,tonumber,' +\n        'tostring,turtle,type,unpack,vector,write,xpcall,_VERSION,__indext,' +\n        // Not included in the script, probably because it wasn't enabled:\n        'HTTP,' +\n        // Keywords (http://www.lua.org/pil/1.3.html).\n        'and,break,do,else,elseif,end,false,for,function,if,in,local,nil,not,' +\n        'or,repeat,return,then,true,until,while,' +\n        // Metamethods (http://www.lua.org/manual/5.2/manual.html).\n        'add,sub,mul,div,mod,pow,unm,concat,len,eq,lt,le,index,newindex,call,' +\n        // Basic functions (http://www.lua.org/manual/5.2/manual.html,\n        // section 6.1).\n        'assert,collectgarbage,dofile,error,_G,getmetatable,inpairs,load,' +\n        'loadfile,next,pairs,pcall,print,rawequal,rawget,rawlen,rawset,select,' +\n        'setmetatable,tonumber,tostring,type,_VERSION,xpcall,' +\n        // Modules (http://www.lua.org/manual/5.2/manual.html, section 6.3).\n        'require,package,string,table,math,bit32,io,file,os,debug',\n    );\n  }\n\n  /**\n   * Initialise the database of variable names.\n   *\n   * @param workspace Workspace to generate code from.\n   */\n  init(workspace: Workspace) {\n    // Call Blockly.CodeGenerator's init.\n    super.init(workspace);\n\n    if (!this.nameDB_) {\n      this.nameDB_ = new Names(this.RESERVED_WORDS_);\n    } else {\n      this.nameDB_.reset();\n    }\n    this.nameDB_.setVariableMap(workspace.getVariableMap());\n    this.nameDB_.populateVariables(workspace);\n    this.nameDB_.populateProcedures(workspace);\n\n    this.isInitialized = true;\n  }\n\n  /**\n   * Prepend the generated code with the variable definitions.\n   *\n   * @param code Generated code.\n   * @returns Completed code.\n   */\n  finish(code: string): string {\n    // Convert the definitions dictionary into a list.\n    const definitions = Object.values(this.definitions_);\n    // Call Blockly.CodeGenerator's finish.\n    code = super.finish(code);\n    this.isInitialized = false;\n\n    this.nameDB_!.reset();\n    return definitions.join('\\n\\n') + '\\n\\n\\n' + code;\n  }\n\n  /**\n   * Naked values are top-level blocks with outputs that aren't plugged into\n   * anything. In Lua, an expression is not a legal statement, so we must assign\n   * the value to the (conventionally ignored) _.\n   * http://lua-users.org/wiki/ExpressionsAsStatements\n   *\n   * @param line Line of generated code.\n   * @return Legal line of code.\n   */\n  scrubNakedValue(line: string): string {\n    return 'local _ = ' + line + '\\n';\n  }\n\n  /**\n   * Encode a string as a properly escaped Lua string, complete with\n   * quotes.\n   *\n   * @param string Text to encode.\n   * @returns Lua string.\n   */\n  quote_(string: string): string {\n    string = string\n      .replace(/\\\\/g, '\\\\\\\\')\n      .replace(/\\n/g, '\\\\\\n')\n      .replace(/'/g, \"\\\\'\");\n    return \"'\" + string + \"'\";\n  }\n\n  /**\n   * Encode a string as a properly escaped multiline Lua string, complete with\n   * quotes.\n   *\n   * @param string Text to encode.\n   * @returns Lua string.\n   */\n  multiline_quote_(string: string): string {\n    const lines = string.split(/\\n/g).map(this.quote_);\n    // Join with the following, plus a newline:\n    // .. '\\n' ..\n    return lines.join(\" .. '\\\\n' ..\\n\");\n  }\n\n  /**\n   * Common tasks for generating Lua from blocks.\n   * Handles comments for the specified block and any connected value blocks.\n   * Calls any statements following this block.\n   * @param block The current block.\n   * @param code The Lua code created for this block.\n   * @param thisOnly True to generate code for only this statement.\n   * @returns Lua code with comments and subsequent blocks added.\n   */\n  scrub_(block: Block, code: string, thisOnly = false): string {\n    let commentCode = '';\n    // Only collect comments for blocks that aren't inline.\n    if (!block.outputConnection || !block.outputConnection.targetConnection) {\n      // Collect comment for this block.\n      let comment = block.getCommentText();\n      if (comment) {\n        comment = stringUtils.wrap(comment, this.COMMENT_WRAP - 3);\n        commentCode += this.prefixLines(comment, '-- ') + '\\n';\n      }\n      // Collect comments for all value arguments.\n      // Don't collect comments for nested statements.\n      for (let i = 0; i < block.inputList.length; i++) {\n        if (block.inputList[i].type === inputTypes.VALUE) {\n          const childBlock = block.inputList[i].connection!.targetBlock();\n          if (childBlock) {\n            comment = this.allNestedComments(childBlock);\n            if (comment) {\n              commentCode += this.prefixLines(comment, '-- ');\n            }\n          }\n        }\n      }\n    }\n    const nextBlock =\n      block.nextConnection && block.nextConnection.targetBlock();\n    const nextCode = thisOnly ? '' : this.blockToCode(nextBlock);\n    return commentCode + code + nextCode;\n  }\n}\n", "/**\n * @license\n * Copyright 2018 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\n/**\n * @file Generating Lua for dynamic variable blocks.\n */\n\n// Former goog.module ID: Blockly.Lua.variablesDynamic\n\n// Lua is dynamically typed.\nexport {\n  variables_get as variables_get_dynamic,\n  variables_set as variables_set_dynamic,\n} from './variables.js';\n", "/**\n * @license\n * Copyright 2021 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\n/**\n * @file Complete helper functions for generating Lua for\n *     blocks.  This is the entrypoint for lua_compressed.js.\n */\n\n// Former goog.module ID: Blockly.Lua.all\n\nimport * as lists from './lua/lists.js';\nimport * as logic from './lua/logic.js';\nimport * as loops from './lua/loops.js';\nimport {LuaGenerator} from './lua/lua_generator.js';\nimport * as math from './lua/math.js';\nimport * as procedures from './lua/procedures.js';\nimport * as text from './lua/text.js';\nimport * as variables from './lua/variables.js';\nimport * as variablesDynamic from './lua/variables_dynamic.js';\n\nexport * from './lua/lua_generator.js';\n\n/**\n * Lua code generator instance.\n */\nexport const luaGenerator = new LuaGenerator();\n\n// Install per-block-type generator functions:\nconst generators: typeof luaGenerator.forBlock = {\n  ...lists,\n  ...logic,\n  ...loops,\n  ...math,\n  ...procedures,\n  ...text,\n  ...variables,\n  ...variablesDynamic,\n};\nfor (const name in generators) {\n  luaGenerator.forBlock[name] = generators[name];\n}\n", "import lua from './lua_compressed.js';\nexport const {\n  LuaGenerator,\n  Order,\n  luaGenerator,\n} = lua;\n"],
  "mappings": "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",
  "names": ["lists_create_empty", "block", "generator", "Order", "HIGH", "lists_create_with", "elements", "Array", "itemCount_", "i", "valueToCode", "NONE", "join", "lists_repeat", "functionName", "provideFunction_", "FUNCTION_NAME_PLACEHOLDER_", "element", "repeatCount", "lists_length", "UNARY", "lists_isEmpty", "RELATIONAL", "lists_indexOf", "item", "list", "getFieldValue", "lists_getIndex", "mode", "where", "match", "at", "ADDITIVE", "getListIndex", "code", "listVar", "nameDB_", "getDistinctName", "NameType", "VARIABLE", "toLowerCase", "lists_setIndex", "value", "lists_getSublist", "where1", "where2", "at1", "at2", "at1Param", "at2Param", "lists_sort", "direction", "type", "lists_split", "input", "delimiter", "Error", "lists_reverse", "controls_if", "n", "STATEMENT_PREFIX", "injectId", "conditionCode", "branchCode", "statementToCode", "STATEMENT_SUFFIX", "prefixLines", "INDENT", "getInput", "logic_compare", "operator", "OPERATORS", "argument0", "argument1", "logic_operation", "order", "AND", "OR", "defaultArgument", "logic_negate", "logic_boolean", "ATOMIC", "logic_null", "logic_ternary", "value_if", "value_then", "value_else", "addContinueLabel", "branch", "indent", "includes", "CONTINUE_STATEMENT", "controls_repeat_ext", "repeats", "getField", "String", "Number", "isNumber", "parseInt", "addLoopTrap", "loopVar", "controls_whileUntil", "until", "controls_for", "variable0", "getVariableName", "startVar", "endVar", "increment", "incValue", "Math", "abs", "step", "controls_forEach", "controls_flow_statements", "xfix", "loop", "getSurroundLoop", "suppressPrefixSuffix", "math_number", "math_arithmetic", "tuple", "MULTIPLICATIVE", "EXPONENTIATION", "math_single", "arg", "math_constant", "CONSTANTS", "math_number_property", "PROPERTIES", "dropdownProperty", "suffix", "inputOrder", "outputOrder", "numberToCheck", "divisor", "math_change", "varName", "math_on_list", "provideSum", "func", "math_modulo", "math_constrain", "argument2", "math_random_int", "math_random_float", "math_atan2", "procedures_defreturn", "funcName", "getProcedureName", "xfix1", "loopTrap", "INFINITE_LOOP_TRAP", "returnValue", "xfix2", "args", "variables", "getVars", "length", "scrub_", "definitions_", "procedures_callreturn", "procedures_callnoreturn", "forBlock", "procedures_ifreturn", "hasReturnValue_", "text", "quote_", "text_join", "element0", "CONCATENATION", "element1", "text_append", "text_length", "text_isEmpty", "text_indexOf", "substring", "text_charAt", "start", "text_getSubstring", "end", "text_changeCase", "text_trim", "LEFT", "RIGHT", "BOTH", "text_print", "text_prompt_ext", "msg", "text_count", "sub", "text_replace", "from", "to", "text_reverse", "variables_get", "variables_set", "LuaGenerator", "CodeGenerator", "constructor", "name", "isInitialized", "key", "addReservedWords", "init", "workspace", "reset", "Names", "RESERVED_WORDS_", "setVariableMap", "getVariableMap", "populateVariables", "populateProcedures", "finish", "definitions", "Object", "values", "scrubNakedValue", "line", "string", "replace", "multiline_quote_", "split", "map", "lines", "thisOnly", "commentCode", "outputConnection", "targetConnection", "comment", "getCommentText", "wrap", "COMMENT_WRAP", "inputList", "inputTypes", "VALUE", "childBlock", "connection", "targetBlock", "allNestedComments", "nextBlock", "nextConnection", "nextCode", "blockToCode", "$jscomp$tmp$exports$module$name", "listName", "opt_at", "controls_ifelse", "controls_repeat", "math_round", "math_trig", "procedures_defnoreturn", "text_prompt", "luaGenerator", "generators", "lists", "logic", "loops", "math", "procedures", "variablesDynamic", "lua"]
}
